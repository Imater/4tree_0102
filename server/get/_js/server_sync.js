// Generated by CoffeeScript 1.7.1
(function() {
  var $, Diff, JSON_stringify, Text, async, jsondiffpatch, logJson, mongoose, sync, _;

  async = require('async');

  mongoose = require('mongoose');

  logJson = require('../../logJson/_js/logJson.js');

  JSON_stringify = require('../../scripts/_js/JSON_stringify.js');

  $ = require('jquery');

  _ = require('underscore');

  jsondiffpatch = require('jsondiffpatch').create({
    objectHash: function(obj) {
      return obj.name || obj.id || obj._id || obj._id || JSON.stringify(obj);
    },
    textDiff: {
      minLength: 3
    }
  });

  require('../../models/_js/model_diff.js');

  Diff = mongoose.model('Diff');

  Text = mongoose.model('Text');

  sync = {
    apply_patch: function(args, dont_save_to_db) {
      var dfd, mythis;
      dfd = $.Deferred();
      mythis = this;
      if (false) {
        console.info('apply patch to ' + args.diff.db_name, args.old_row);
      }
      args.old_row = jsondiffpatch.patch(args.old_row, args.diff.patch);
      args.old_row._sha1 = JSON_stringify.JSON_stringify(args.old_row)._sha1;
      if (false) {
        logJson('new_row', args.new_row);
      }
      args.old_row._tm = new Date();
      args.old_row._diff = args.diff;
      args.old_row.save(function(err) {
        return dfd.resolve(args);
      });
      return dfd.promise();
    },
    combineDiffsByTime: function(_id) {
      var dfd;
      dfd = $.Deferred();
      Diff.find({
        'db_id': _id
      }, void 0, {
        sort: {
          tm: 1
        }
      }, function(err, rows) {
        var answer;
        if (!rows[0]) {
          console.info('NOT FOUND IN DIFFS - ' + _id);
        }
        answer = rows[0].body;
        return async.eachSeries(rows, function(dif, callback) {
          logJson('body was = ', answer);
          answer = jsondiffpatch.patch(answer, dif.patch);
          logJson('body now = ', answer);
          logJson('dif = ', dif.patch);
          answer._sha1 = JSON_stringify.JSON_stringify(answer)._sha1;
          return callback();
        }, function() {
          return dfd.resolve(answer);
        });
      });
      return dfd.promise();
    },
    combineAllDiffs: function(req, res) {
      var answer, mythis, _id;
      mythis = this;
      _id = req.query._id;
      mythis.combineDiffsByTime(_id).then(function(combined) {
        return res.send(combined);
      });
      return answer = {};
    },
    Merge: function(diff) {
      var delta1, dfd;
      dfd = new $.Deferred();
      if (false) {
        logJson('diff = ', diff);
      }
      delta1 = diff.patch;
      Diff.findOne({
        _sha1: diff._sha1,
        db_id: diff._id
      }, void 0, function(err, doc0) {
        var doc1;
        if (false) {
          logJson('doc0new', doc0.new_body);
        }
        doc1 = jsondiffpatch.patch(doc0.new_body, delta1);
        logJson('doc1', doc1);
        return global._db_models[diff.db_name].findOne({
          _id: diff._id
        }, void 0, function(err, doc2) {
          var delta2, doc3, main_diff;
          logJson('doc2', doc2);
          delta2 = jsondiffpatch.diff(doc0.new_body, doc2.toObject());
          if (delta2['_sha1']) {
            delta2['_sha1'] = void 0;
          }
          if (delta2['_tm']) {
            delta2['_tm'] = void 0;
          }
          logJson('delta2', delta2);
          doc3 = jsondiffpatch.patch(doc1, delta2);
          doc3 = jsondiffpatch.patch(doc3, delta1);
          main_diff = jsondiffpatch.diff(doc2.toObject(), doc3);
          if (false) {
            logJson('DOC3', doc3);
          }
          if (false) {
            logJson('MAIN_DIFF', main_diff);
          }
          doc2 = _.extend(doc2, doc3);
          console.info('doc2', doc2);
          doc2._diff = diff;
          doc2._tm = new Date();
          return doc2.save(function(err, doc) {
            console.info('merged saved', err, doc);
            return dfd.resolve(doc);
          });
        });
      });
      return dfd.promise();
    }
  };

  exports.get2 = function(req, res) {
    return global._db_models['tree'].findOne({
      _id: req.query._id
    }, void 0, function(err, row) {
      var answer;
      console.info(row);
      answer = JSON_stringify.JSON_stringify(row);
      console.info(answer);
      return res.send(answer);
    });
  };

  exports.get = function(req, res) {
    return exports.fullSyncUniversal(req, res).then(function(data_to_client) {
      return res.send(data_to_client);
    });
  };

  exports.fullSyncUniversal = function(req, res) {
    var confirm_count, dfd, diffs, last_sync_time, machine, new_db_elements, sha1_sign, user_id;
    dfd = new $.Deferred();
    diffs = req.body.diffs;
    new_db_elements = req.body.new_db_elements;
    user_id = req.body.user_id;
    last_sync_time = req.query.last_sync_time;
    machine = req.query.machine;
    confirm_count = 0;
    sha1_sign = req.query.machine + JSON_stringify.JSON_stringify({
      diffs: diffs,
      new_db_elements: new_db_elements
    })._sha1;
    if (sha1_sign !== req.body.sha1_sign) {
      if (false) {
        console.info('Error of signing sync http: ' + req.body.sha1_sign + ' != ' + sha1_sign);
      }
      res.send();
    } else {
      async.series([
        function(callback_main) {
          if (new_db_elements) {
            return async.eachLimit(Object.keys(new_db_elements), 50, function(db_name, callback) {
              var new_elements;
              new_elements = new_db_elements[db_name];
              if (new_elements) {
                return async.eachLimit(Object.keys(new_elements), 50, function(doc_id, callback2) {
                  var DB_MODEL, db_model, doc;
                  doc = new_elements[doc_id];
                  console.info('need_save ' + doc_id, doc);
                  DB_MODEL = global._db_models[db_name];
                  db_model = new DB_MODEL(doc);
                  return db_model.save(function(err, saved) {
                    console.info('saved', err, saved);
                    return callback2();
                  });
                }, function() {});
              } else {
                return callback();
              }
            }, function() {
              return callback_main();
            });
          } else {
            return callback_main();
          }
        }, function(callback_main) {
          var send_to_client;
          send_to_client = {};
          if (diffs) {
            return async.eachLimit(Object.keys(diffs), 50, function(diff_id, callback) {
              var diff;
              diff = diffs[diff_id];
              if (false) {
                logJson('diff ' + diff._id, diff);
              }
              return global._db_models[diff.db_name].findOne({
                '_sha1': diff._sha1,
                '_id': diff._id
              }, void 0, function(err, row) {
                if (row) {
                  if (false) {
                    console.info('found in db ', row);
                  }
                  return sync.apply_patch({
                    old_row: row,
                    diff: diff
                  }).then(function(args) {
                    if (!send_to_client[diff.db_name]) {
                      send_to_client[diff.db_name] = {
                        confirm: {}
                      };
                    }
                    send_to_client[diff.db_name]['confirm'][args.old_row._id] = {
                      _sha1: args.old_row._sha1,
                      _tm: args.old_row._tm
                    };
                    confirm_count++;
                    return callback();
                  });
                } else {
                  console.info('Error, dont found ' + diff._sha1 + ', need seek DIFF');
                  return sync.Merge(diff).then(function(doc) {
                    if (doc) {
                      if (!send_to_client[diff.db_name]) {
                        send_to_client[diff.db_name] = {
                          confirm: {}
                        };
                      }
                      send_to_client[diff.db_name]['confirm'][doc._id] = {
                        _sha1: doc._sha1,
                        _tm: doc._tm,
                        _doc: doc,
                        merged: true
                      };
                      confirm_count++;
                    }
                    return callback();
                  });
                }
              });
            }, function() {
              return async.each(Object.keys(global._db_models), function(db_name, callback) {
                var tm;
                tm = new Date(JSON.parse(last_sync_time)).toISOString();
                if (false) {
                  console.info('FIND', {
                    _tm: {
                      $gt: tm
                    }
                  });
                }
                return global._db_models[db_name].find({
                  _tm: {
                    $gt: tm
                  }
                }, function(err, docs) {
                  return async.each(docs, function(doc, callback2) {
                    var confirm, _ref, _ref1;
                    if ((confirm = send_to_client != null ? (_ref = send_to_client[db_name]) != null ? (_ref1 = _ref['confirm']) != null ? _ref1[doc._id] : void 0 : void 0 : void 0)) {
                      if (confirm._sha1 !== doc._sha1) {
                        confirm._doc = doc;
                        confirm.becouse_new = true;
                      }
                    } else {
                      if (!send_to_client[db_name]) {
                        send_to_client[db_name] = {
                          confirm: {}
                        };
                      }
                      send_to_client[db_name]['confirm'][doc._id] = {
                        _sha1: doc._sha1,
                        _tm: doc._tm,
                        _doc: doc,
                        just_new: true
                      };
                    }
                    return callback2();
                  }, function(docs_filtered) {
                    return callback();
                  });
                });
              }, function() {
                var clients;
                send_to_client.server_time = new Date();
                send_to_client.confirm_count = confirm_count;
                logJson('send_to_client', send_to_client);
                dfd.resolve(send_to_client);
                if (confirm_count > 0) {
                  clients = global.io.sockets.clients('user_id:' + user_id);
                  if (clients) {
                    async.each(Object.keys(clients), function(client_i, callback3) {
                      var client;
                      client = clients[client_i];
                      client.get('nickname', function(err, nickname) {
                        nickname = JSON.parse(nickname);
                        if (nickname && nickname.machine !== machine) {
                          return client.emit('need_sync_now');
                        }
                      });
                      return callback3();
                    }, function() {
                      return console.info('info sended by socket...');
                    });
                  }
                }
                return callback_main();
              });
            });
          } else {
            return dfd.resolve();
          }
        }
      ], function() {
        return console.info('SYNC ENDED!!!');
      });
    }
    return dfd.promise();
  };

}).call(this);

//# sourceMappingURL=server_sync.map
