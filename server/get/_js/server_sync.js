// Generated by CoffeeScript 1.7.1
(function() {
  var $, Diff, JSON_stringify, MYLOG, Text, async, jsondiffpatch, logJson, mongoose, sync, winston, _;

  async = require('async');

  mongoose = require('mongoose');

  logJson = require('../../logJson/_js/logJson.js');

  JSON_stringify = require('../../scripts/_js/JSON_stringify.js');

  $ = require('jquery');

  _ = require('underscore');

  winston = require('winston');

  MYLOG = require('../../scripts/_js/mylog.js').mylog;

  jsondiffpatch = require('jsondiffpatch').create({
    objectHash: function(obj) {
      return obj.name || obj.id || obj._id || obj._id || JSON.stringify(obj);
    },
    textDiff: {
      minLength: 3
    }
  });

  require('../../models/_js/model_diff.js');

  Diff = mongoose.model('Diff');

  Text = mongoose.model('Text');

  sync = {
    apply_patch: function(args, dont_save_to_db) {
      var dfd, mythis;
      dfd = $.Deferred();
      mythis = this;
      MYLOG.log('sync', 'apply_patch: Применяю патч к базе ' + args.diff.db_name, {
        patch: args.old_row,
        args: args
      });
      args.old_row = jsondiffpatch.patch(args.old_row, args.diff.patch);
      args.old_row._sha1 = JSON_stringify.JSON_stringify(args.old_row)._sha1;
      MYLOG.log('sync', 'apply_patch: После применения', args.old_row);
      args.old_row._tm = new Date();
      args.old_row._diff = args.diff;
      args.old_row.save(function(err) {
        return dfd.resolve(args);
      });
      return dfd.promise();
    },
    combineDiffsByTime: function(_id) {
      var dfd;
      dfd = $.Deferred();
      Diff.find({
        'db_id': _id
      }, void 0, {
        sort: {
          tm: 1
        }
      }, function(err, rows) {
        var answer;
        if (!rows[0]) {
          MYLOG.log('sync', 'combineDiffsByTime: Нашёл в базе diff по id=' + _id, {
            rows: rows
          });
        }
        answer = rows[0].body;
        return async.eachSeries(rows, function(dif, callback) {
          MYLOG.log('sync', 'combineDiffsByTime: Раньше (нашёл в diff) body was = ', answer);
          answer = jsondiffpatch.patch(answer, dif.patch);
          MYLOG.log('sync', 'combineDiffsByTime: Применил патч, теперь body = ', {
            body: answer,
            patch: patch
          });
          answer._sha1 = JSON_stringify.JSON_stringify(answer)._sha1;
          MYLOG.log('sync', 'combineDiffsByTime: Применил патч, теперь _sha1 = ', {
            sha1: answer._sha1
          });
          return callback();
        }, function() {
          return dfd.resolve(answer);
        });
      });
      return dfd.promise();
    },
    combineAllDiffs: function(req, res) {
      var answer, mythis, _id;
      mythis = this;
      _id = req.query._id;
      mythis.combineDiffsByTime(_id).then(function(combined) {
        return res.send(combined);
      });
      return answer = {};
    },
    Merge: function(diff) {
      var delta1, dfd;
      dfd = new $.Deferred();
      MYLOG.log('sync', 'Merge: diff (смотри diff.patch) = ', {
        diff: diff
      });
      delta1 = diff.patch;
      Diff.findOne({
        _sha1: diff._sha1,
        db_id: diff._id
      }, void 0, function(err, doc0) {
        var doc1;
        if (doc0) {
          MYLOG.log('sync', 'Merge: Нашёл в базе diff', {
            new_body: doc0.new_body
          });
          doc1 = jsondiffpatch.patch(doc0.new_body, delta1);
          MYLOG.log('sync', 'Merge: Применил diff.patch, теперь doc1 = ', {
            doc1: doc1
          });
          return global._db_models[diff.db_name].findOne({
            _id: diff._id
          }, void 0, function(err, doc2) {
            var delta2, doc3, main_diff;
            MYLOG.log('sync', 'Merge: Нашёл в базе данных ' + diff.db_name + ' doc2 = ', {
              doc2: doc2
            });
            delta2 = jsondiffpatch.diff(doc0.new_body, doc2.toObject());
            if (delta2['_sha1']) {
              delta2['_sha1'] = void 0;
            }
            if (delta2['_tm']) {
              delta2['_tm'] = void 0;
            }
            MYLOG.log('sync', 'Merge: Применил к doc0.new_body ' + diff.db_name + ' doc2 = ', {
              delta2: delta2,
              doc0new_body: doc0.new_body,
              doc2: doc2.toObject()
            });
            doc3 = jsondiffpatch.patch(doc1, delta2);
            doc3 = jsondiffpatch.patch(doc3, delta1);
            main_diff = jsondiffpatch.diff(doc2.toObject(), doc3);
            MYLOG.log('sync', 'Merge: Сгенерировал объединённый текст doc3 ', {
              doc1: doc1,
              doc2: doc2,
              doc3: doc3,
              delta1: delta1,
              delta2: delta2,
              delta3: delta3
            });
            MYLOG.log('sync', 'Merge: MAIN_DIFF теперь = ', {
              main_diff: main_diff
            });
            doc2 = _.extend(doc2, doc3);
            MYLOG.log('sync', 'Merge: Extend doc2 = _.extend( doc2, doc3) = ', {
              doc2: doc2
            });
            doc2._diff = diff;
            doc2._tm = new Date();
            return doc2.save(function(err, doc) {
              MYLOG.log('sync', 'Merge: Merged saved', {
                err: err,
                doc: doc
              });
              return dfd.resolve(doc);
            });
          });
        } else {
          return dfd.resolve();
        }
      });
      return dfd.promise();
    }
  };

  exports.get2 = function(req, res) {
    return global._db_models['tree'].findOne({
      _id: req.query._id
    }, void 0, function(err, row) {
      var answer;
      answer = JSON_stringify.JSON_stringify(row);
      return res.send(answer);
    });
  };

  exports.get = function(req, res) {
    MYLOG.profile('Время исполнения синхронизации');
    return exports.fullSyncUniversal(req, res).then(function(data_to_client) {
      res.send(data_to_client);
      return MYLOG.profile('Время исполнения синхронизации');
    });
  };

  exports.fullSyncUniversal = function(req, res) {
    var confirm_count, dfd, diffs, last_sync_time, machine, new_db_elements, send_to_client, sha1_sign, user_id;
    dfd = new $.Deferred();
    diffs = req.body.diffs;
    new_db_elements = req.body.new_db_elements;
    user_id = req.body.user_id;
    last_sync_time = req.query.last_sync_time;
    machine = req.query.machine;
    confirm_count = 0;
    MYLOG.log('sync', 'Начинаю синхронизацию для machine=' + machine, {
      diffs: diffs,
      new_db_elements: new_db_elements,
      last_sync_time: last_sync_time
    });
    sha1_sign = req.query.machine + JSON_stringify.JSON_stringify({
      diffs: diffs,
      new_db_elements: new_db_elements
    })._sha1;
    if (sha1_sign !== req.body.sha1_sign) {
      MYLOG.log('sync', 'SHA1sign: Ошибка подписи http: ' + req.body.sha1_sign + ' != ' + sha1_sign);
      res.send();
    } else {
      send_to_client = {};
      async.series([
        function(callback_main) {
          if (new_db_elements) {
            MYLOG.log('sync', 'NEW_DB_ELEMENTS: Начинаю обработку ', {
              new_db_elements: new_db_elements
            });
            return async.eachLimit(Object.keys(new_db_elements), 50, function(db_name, callback) {
              var new_elements;
              new_elements = new_db_elements[db_name];
              MYLOG.log('sync', 'NEW_DB_ELEMENTS: Обрабатываю первый ', {
                new_elements: new_elements
              });
              if (new_elements) {
                return async.eachLimit(Object.keys(new_elements), 50, function(doc_id, callback2) {
                  var DB_MODEL, db_model, doc;
                  doc = new_elements[doc_id];
                  MYLOG.log('sync', 'NEW_DB_ELEMENTS: Сейчас буду сохранять doc', {
                    doc: doc
                  });
                  DB_MODEL = global._db_models[db_name];
                  doc._tm = new Date();
                  db_model = new DB_MODEL(doc);
                  MYLOG.log('sync', 'NEW_DB_ELEMENTS: Документ подготовил ', {
                    db_model: db_model
                  });
                  return db_model.save(function(err, saved) {
                    console.info('SAVED - ', err, saved);
                    if (saved) {
                      confirm_count++;
                      MYLOG.log('sync', 'NEW_DB_ELEMENTS: Успешно сохранил в базу', {
                        err: err,
                        saved: saved
                      });
                    } else {
                      MYLOG.log('sync', 'NEW_DB_ELEMENTS: Ошибка сохранения', {
                        err: err
                      });
                    }
                    if (saved && false) {
                      if (!send_to_client[db_name]) {
                        send_to_client[db_name] = {
                          confirm: {}
                        };
                      }
                      send_to_client[db_name]['confirm'][saved._id] = {
                        _sha1: saved._sha1,
                        _tm: saved._tm
                      };
                      MYLOG.log('sync', 'NEW_DB_ELEMENTS: Добавил в список подтверждённых', {
                        send_to_client: send_to_client
                      });
                    }
                    return callback2();
                  });
                }, function() {
                  MYLOG.log('sync', 'NEW_DB_ELEMENTS: Новые Элементы обработаны', {
                    new_elements: new_elements
                  });
                  return callback();
                });
              } else {
                MYLOG.log('sync', 'NEW_DB_ELEMENTS: Новые Элементы не обнаружены', {
                  new_elements: new_elements
                });
                return callback();
              }
            }, function() {
              return callback_main();
            });
          } else {
            return callback_main();
          }
        }, function(callback_main) {
          if (diffs) {
            MYLOG.log('sync', 'DIFFS: Начинаю обрабатывать изменения', {
              diffs: diffs
            });
            return async.eachLimit(Object.keys(diffs), 50, function(diff_id, callback) {
              var diff;
              diff = diffs[diff_id];
              MYLOG.log('sync', 'DIFFS: Одно из изменений!!!', {
                diff: diff
              });
              return global._db_models[diff.db_name].findOne({
                '_sha1': diff._sha1,
                '_id': diff._id
              }, void 0, function(err, row) {
                if (row) {
                  MYLOG.log('sync', 'DIFFS: 1. Нашёл элемент в основной базе', {
                    row: row
                  });
                  return sync.apply_patch({
                    old_row: row,
                    diff: diff
                  }).then(function(args) {
                    if (!send_to_client[diff.db_name]) {
                      send_to_client[diff.db_name] = {
                        confirm: {}
                      };
                    }
                    send_to_client[diff.db_name]['confirm'][args.old_row._id] = {
                      _sha1: args.old_row._sha1,
                      _tm: args.old_row._tm
                    };
                    MYLOG.log('sync', 'DIFFS: 1. Применил патч, получил ответ', {
                      args: args,
                      send_to_client: send_to_client
                    });
                    confirm_count++;
                    return callback();
                  });
                } else {
                  MYLOG.log('sync', 'DIFFS: 2. В основоной базе нет, запускаю Merge...');
                  if (diff) {
                    return sync.Merge(diff).then(function(doc) {
                      if (doc) {
                        if (!send_to_client[diff.db_name]) {
                          send_to_client[diff.db_name] = {
                            confirm: {}
                          };
                        }
                        send_to_client[diff.db_name]['confirm'][doc._id] = {
                          _sha1: doc._sha1,
                          _tm: doc._tm,
                          _doc: doc,
                          merged: true
                        };
                        confirm_count++;
                        MYLOG.log('sync', 'DIFFS: 2. Merge применён, подтверждаю', {
                          doc: doc,
                          send_to_client: send_to_client
                        });
                      }
                      return callback();
                    });
                  } else {
                    return callback();
                  }
                }
              });
            }, function() {
              MYLOG.log('sync', 'NEW: Все дифы обработаны, пошли дальше. Сейчас будем искать изменившиеся элементы.');
              return async.each(Object.keys(global._db_models), function(db_name, callback) {
                var tm;
                tm = new Date(JSON.parse(last_sync_time)).toISOString();
                MYLOG.log('sync', 'NEW: Ищем все дела с датой больше ' + tm, {
                  _tm: {
                    $gt: tm
                  }
                });
                return global._db_models[db_name].find({
                  _tm: {
                    $gt: tm
                  }
                }, function(err, docs) {
                  MYLOG.log('sync', 'NEW: Нашли дела с датой больше ' + tm, {
                    err: err,
                    docs: docs
                  });
                  return async.each(docs, function(doc, callback2) {
                    var confirm, _ref, _ref1;
                    if ((confirm = send_to_client != null ? (_ref = send_to_client[db_name]) != null ? (_ref1 = _ref['confirm']) != null ? _ref1[doc._id] : void 0 : void 0 : void 0)) {
                      MYLOG.log('sync', 'NEW: В базе подтверждений такой элемент есть, значит мы его сейчас меняли', {
                        confirm: confirm
                      });
                      if (confirm._sha1 !== doc._sha1) {
                        MYLOG.log('sync', 'NEW: Но confirm._sha1 не совпадает с базой', {
                          confirm_sha1: confirm._sha1,
                          doc: doc._sha1
                        });
                        confirm._doc = doc;
                        confirm.becouse_new = true;
                      }
                    } else {
                      MYLOG.log('sync', 'NEW: Нашли НОВЫЙ элемент, будем отправлять клиенту', {
                        doc: doc
                      });
                      if (!send_to_client[db_name]) {
                        send_to_client[db_name] = {
                          confirm: {}
                        };
                      }
                      send_to_client[db_name]['confirm'][doc._id] = {
                        _sha1: doc._sha1,
                        _tm: doc._tm,
                        _doc: doc,
                        just_new: true
                      };
                      MYLOG.log('sync', 'NEW: Нашли НОВЫЙ элемент, будем отправлять клиенту send_to_client[db_name][confirm][doc._id]', {
                        send_to_client: send_to_client[db_name]['confirm'][doc._id]
                      });
                    }
                    return callback2();
                  }, function(docs_filtered) {
                    return callback();
                  });
                });
              }, function() {
                return callback_main();
              });
            });
          }
        }
      ], function() {
        var clients;
        send_to_client.server_time = new Date();
        send_to_client.confirm_count = confirm_count;
        dfd.resolve(send_to_client);
        if (confirm_count > 0) {
          clients = global.io.sockets.clients('user_id:' + user_id);
          MYLOG.log('sync', 'SOCKETS: Есть что подтверждать клиентам ' + clients.length, {
            clients: clients
          });
          if (clients) {
            async.each(Object.keys(clients), function(client_i, callback3) {
              var client;
              client = clients[client_i];
              client.get('nickname', function(err, nickname) {
                nickname = JSON.parse(nickname);
                if (nickname && nickname.machine !== machine) {
                  MYLOG.log('sync', 'SOCKETS: Клиента ' + nickname + ' попросили синхронизироваться', {
                    client_i: client_i
                  });
                  return client.emit('need_sync_now');
                }
              });
              return callback3();
            }, function() {
              return MYLOG.log('sync', 'SOCKETS: Всех клиентов оповестили');
            });
          }
        }
        return MYLOG.log('sync', 'Синхронизация завершена', {
          send_to_client: send_to_client
        });
      });
    }
    return dfd.promise();
  };

}).call(this);

//# sourceMappingURL=server_sync.map
