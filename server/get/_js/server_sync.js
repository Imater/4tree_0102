// Generated by CoffeeScript 1.6.3
(function() {
  var $, Diff, JSON_stringify, async, jsondiffpatch, logJson, mongoose, sync;

  async = require('async');

  mongoose = require('mongoose');

  logJson = require('../../logJson/_js/logJson.js');

  JSON_stringify = require('../../scripts/_js/JSON_stringify.js');

  $ = require('jquery');

  jsondiffpatch = require('jsondiffpatch').create({
    objectHash: function(obj) {
      return obj.name || obj.id || obj._id || obj._id || JSON.stringify(obj);
    }
  });

  require('../../models/_js/model_diff.js');

  Diff = mongoose.model('Diff');

  sync = {
    apply_patch: function(args, dont_save_to_db) {
      /*
      args = {
        old_row
        diff: {
          patch
          db_name
          _sha1
          user_id
          machine
          tm
        }
      }
      */

      var dfd, mythis;
      dfd = $.Deferred();
      mythis = this;
      if (false) {
        console.info('apply patch to ' + args.diff.db_name, args.old_row);
      }
      args.new_row = jsondiffpatch.patch(JSON.parse(JSON.stringify(args.old_row)), args.diff.patch);
      args.new_row._sha1 = JSON_stringify.JSON_stringify(args.new_row)._sha1;
      if (false) {
        logJson('new_row', args.new_row);
      }
      async.parallel([
        function(callback) {
          return mythis.save_diff(args).then(function() {
            return callback();
          });
        }, function(callback) {
          if (!dont_save_to_db) {
            return mythis.save_to_db(args).then(function() {
              return callback();
            });
          } else {
            return callback();
          }
        }
      ], function() {
        return dfd.resolve(args);
      });
      return dfd.promise();
    },
    save_diff: function(args) {
      var dfd, new_diff;
      dfd = $.Deferred();
      if (false) {
        console.info('save_diff', args.old_row, args.new_row);
      }
      new_diff = new Diff();
      new_diff.db_id = args.diff._id;
      new_diff.patch = args.diff.patch;
      new_diff._tm = args.diff._tm;
      new_diff.body = args.old_row;
      new_diff.new_body = args.new_row;
      new_diff.new_sha1 = JSON_stringify.JSON_stringify(args.new_row)._sha1;
      new_diff.user_id = args.diff.user_id;
      new_diff.machine = args.diff.machine;
      new_diff.db_name = args.diff.db_name;
      new_diff._sha1 = args.diff._sha1;
      new_diff.del = 0;
      new_diff.save(function(err, doc) {
        return dfd.resolve(doc);
      });
      return dfd.promise();
    },
    save_to_db: function(args) {
      var dfd;
      dfd = $.Deferred();
      args.new_row._tm = new Date();
      global._db_models[args.diff.db_name].update({
        _id: args.diff._id
      }, args.new_row, {
        upsert: false
      }, function(err, doc) {
        if (false) {
          console.info('db_saved', err, doc);
        }
        return dfd.resolve(err);
      });
      return dfd.promise();
    },
    combineDiffsByTime: function(_id) {
      var dfd;
      dfd = $.Deferred();
      Diff.find({
        'db_id': _id
      }, void 0, {
        sort: {
          tm: 1
        }
      }, function(err, rows) {
        var answer;
        answer = rows[0].body;
        return async.eachSeries(rows, function(dif, callback) {
          logJson('body was = ', answer);
          answer = jsondiffpatch.patch(answer, dif.patch);
          logJson('body now = ', answer);
          logJson('dif = ', dif.patch);
          answer._sha1 = JSON_stringify.JSON_stringify(answer)._sha1;
          return callback();
        }, function() {
          return dfd.resolve(answer);
        });
      });
      return dfd.promise();
    },
    combineAllDiffs: function(req, res) {
      var answer, mythis, _id;
      mythis = this;
      _id = req.query._id;
      mythis.combineDiffsByTime(_id).then(function(combined) {
        return res.send(combined);
      });
      return answer = {};
    }
  };

  exports.get2 = function(req, res) {
    return sync.combineAllDiffs(req, res);
  };

  exports.get = function(req, res) {
    return exports.fullSyncUniversal(req, res).then(function(data_to_client) {
      return res.send(data_to_client);
    });
  };

  exports.fullSyncUniversal = function(req, res) {
    var confirm_count, dfd, diffs, last_sync_time, machine, send_to_client, sha1_sign, user_id;
    dfd = new $.Deferred();
    diffs = req.body.diffs;
    user_id = req.body.user_id;
    last_sync_time = req.query.last_sync_time;
    machine = req.query.machine;
    confirm_count = 0;
    sha1_sign = req.query.machine + JSON_stringify.JSON_stringify(diffs)._sha1;
    if (sha1_sign !== req.body.sha1_sign) {
      if (false) {
        console.info('Error of signing sync http: ' + req.body.sha1_sign + ' != ' + sha1_sign);
      }
      res.send();
    } else {
      send_to_client = {};
      async.eachLimit(diffs, 50, function(diff, callback) {
        if (false) {
          logJson('diff ' + diff._id, diff);
        }
        return global._db_models[diff.db_name].findOne({
          '_sha1': diff._sha1,
          '_id': diff._id
        }, void 0, function(err, row) {
          if (row) {
            if (false) {
              console.info('found in db ', row);
            }
            return sync.apply_patch({
              old_row: row,
              diff: diff
            }).then(function(args) {
              if (!send_to_client[args.new_row.db_name]) {
                send_to_client[diff.db_name] = {
                  confirm: {}
                };
              }
              send_to_client[diff.db_name]['confirm'][args.new_row._id] = {
                _sha1: args.new_row._sha1,
                _tm: args.new_row._tm
              };
              confirm_count++;
              return callback();
            });
          } else {
            return Diff.findOne({
              '_sha1': diff._sha1,
              'db_id': diff._id
            }, void 0, function(err, row) {
              if (false) {
                logJson('dont found in db, but found in diffs', row.body);
              }
              return sync.apply_patch({
                old_row: row,
                diff: diff
              }, 'dont_save_to_db').then(function(args) {
                return sync.combineDiffsByTime(args.new_row.db_id).then(function(combined) {
                  var tm;
                  logJson('combined = ', combined);
                  if (combined) {
                    logJson('stoping diff', diff);
                  }
                  tm = new Date();
                  if (!send_to_client[args.new_row.db_name]) {
                    send_to_client[diff.db_name] = {
                      confirm: {},
                      merged: {}
                    };
                  }
                  send_to_client[diff.db_name]['merged'][combined._id] = {
                    combined: combined
                  };
                  send_to_client[diff.db_name]['confirm'][combined._id] = {
                    _sha1: combined._sha1,
                    _tm: combined._tm
                  };
                  confirm_count++;
                  return global._db_models[args.diff.db_name].findOne({
                    _id: args.diff._id
                  }, void 0, function(err, now_doc) {
                    var empty_diff;
                    empty_diff = JSON.parse(JSON.stringify(diff));
                    empty_diff._sha1 = now_doc._sha1;
                    empty_diff.machine = 'server';
                    empty_diff.patch = void 0;
                    empty_diff._tm = empty_diff._tm + 500;
                    return sync.apply_patch({
                      old_row: now_doc,
                      diff: empty_diff
                    }, 'dont_save_to_db').then(function(args) {
                      if (false) {
                        console.info('saved_original', args);
                      }
                      combined._tm = new Date();
                      return global._db_models[args.diff.db_name].update({
                        _id: args.diff._id
                      }, combined, {
                        upsert: false
                      }, function(err, doc) {
                        if (false) {
                          console.info('saved from diff', err, doc);
                        }
                        return callback();
                      });
                    });
                  });
                });
              });
            });
          }
        });
      }, function() {
        return async.each(Object.keys(global._db_models), function(db_name, callback) {
          var tm;
          tm = new Date(JSON.parse(last_sync_time)).toISOString();
          if (false) {
            console.info('FIND', {
              _tm: {
                $gt: tm
              }
            });
          }
          return global._db_models[db_name].find({
            _tm: {
              $gt: tm
            }
          }, function(err, docs) {
            return async.filter(docs, function(doc, callback2) {
              var need, _ref, _ref1, _ref2;
              if ((send_to_client != null ? (_ref = send_to_client[db_name]) != null ? (_ref1 = _ref['confirm']) != null ? (_ref2 = _ref1[doc._id]) != null ? _ref2._sha1 : void 0 : void 0 : void 0 : void 0) === doc._sha1) {
                need = false;
              } else {
                need = true;
              }
              return callback2(need);
            }, function(docs_filtered) {
              if (false) {
                console.info({
                  docs_filtered: docs_filtered
                });
              }
              if (docs_filtered.length) {
                if (!send_to_client[db_name]) {
                  send_to_client[db_name] = {};
                }
                send_to_client[db_name].new_data = docs_filtered;
              }
              return callback();
            });
          });
        }, function() {
          var clients;
          send_to_client.server_time = new Date();
          send_to_client.confirm_count = confirm_count;
          dfd.resolve(send_to_client);
          if (confirm_count > 0) {
            clients = global.io.sockets.clients('user_id:' + user_id);
            if (clients) {
              return async.each(Object.keys(clients), function(client_i, callback3) {
                var client;
                client = clients[client_i];
                client.get('nickname', function(err, nickname) {
                  nickname = JSON.parse(nickname);
                  if (nickname && nickname.machine !== machine) {
                    return client.emit('need_sync_now');
                  }
                });
                return callback3();
              }, function() {
                return console.info('info sended by socket');
              });
            }
          }
        });
      });
    }
    return dfd.promise();
  };

}).call(this);
