// Generated by CoffeeScript 1.6.3
/*
usage: <textarea ng-model="content" redactor></textarea>

additional options:
redactor: hash (pass in a redactor options hash)
*/


(function() {
  angular.module("angular-redactor", []).directive("smartRedactor", [
    "$timeout", "$rootScope", "db_tree", function($timeout, $rootScope, db_tree) {
      return {
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attrs, ngModel) {
          var $_element, additionalOptions, editor, getCurrent, options, resizecontent, setCurrent, updateModel;
          updateModel = function(value) {
            return scope.$apply(function() {
              var text_id;
              text_id = ngModel.$viewValue;
              if (text_id) {
                return db_tree.setText(text_id, value);
              }
            });
          };
          resizecontent = _.debounce(function() {
            return $(element).parents('.content').scroll();
          }, 100);
          $(window).resize(function() {
            return resizecontent();
          });
          options = {
            boldTag: 'b',
            changeCallback: _.debounce(function(value) {
              return updateModel(value);
            }, 100),
            imageUpload: '/api/v1/uploadImage/?id=' + $rootScope.$$childTail.set.user_id,
            clipboardUploadUrl: '/api/v1/uploadImage/?id=' + $rootScope.$$childTail.set.user_id
          };
          additionalOptions = (attrs.smartRedactor ? scope.$eval(attrs.smartRedactor) : {});
          editor = void 0;
          $_element = angular.element(element);
          angular.extend(options, additionalOptions);
          $timeout(function() {
            editor = $_element.redactor(options);
            return ngModel.$render();
          }, 10);
          getCurrent = function() {
            var current, first_parent, parent, path;
            path = [];
            parent = $($_element.redactor("getParent"));
            first_parent = parent;
            current = $($_element.redactor("getCurrent"));
            path.push({
              element: parent,
              index: parent.index()
            });
            while (parent && parent.length && !parent.hasClass('redactor_editor')) {
              parent = parent.parent();
              if (parent.length) {
                path.push({
                  element: parent,
                  index: parent.index()
                });
                console.info('?'.parent);
              }
            }
            return {
              first_parent: first_parent,
              current: current,
              path: path
            };
          };
          setCurrent = function(old_position) {
            var path_reverse;
            path_reverse = old_position.path.reverse();
            element = $('body');
            _.each(path_reverse, function(path) {
              var _ref, _ref1, _ref2;
              if (path.element && ((_ref = path.element[0]) != null ? _ref.length : void 0)) {
                return element = element.find(path.element[0]);
              } else {
                if ($(path.element[0]).hasClass('redactor_editor')) {
                  return element = $(path.element[0]);
                } else {
                  return element = element.find(((_ref1 = path.element) != null ? (_ref2 = _ref1[0]) != null ? _ref2.localName : void 0 : void 0) + ':eq(' + path.index + ')');
                }
              }
            });
            return element;
          };
          $rootScope.$on('refresh_editor', _.debounce(function(value) {
            return db_tree.getText(ngModel.$viewValue).then(function(text_element) {
              var offset, old_element, old_position;
              old_position = getCurrent();
              if (old_position.first_parent && old_position.first_parent.length) {
                offset = $_element.redactor("getCaretOffset", old_position.first_parent[0]);
              } else {
                offset = 0;
              }
              $_element.redactor("set", (text_element != null ? text_element.text : void 0) || "", false);
              old_element = setCurrent(old_position);
              if (old_element && old_element.html()) {
                if (offset > old_element.html().length) {
                  offset = old_element.html().length;
                }
                try {
                  if (old_element.length) {
                    return $_element.redactor("setCaret", old_element, offset);
                  }
                } catch (_error) {
                  return console.info('error of caret');
                }
              }
            });
          }, 1));
          return ngModel.$render = function() {
            if (angular.isDefined(editor)) {
              return db_tree.getText(ngModel.$viewValue).then(function(text_element) {
                return $_element.redactor("set", (text_element != null ? text_element.text : void 0) || "", false);
              });
            }
          };
        }
      };
    }
  ]);

}).call(this);
