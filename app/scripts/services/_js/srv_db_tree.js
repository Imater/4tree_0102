// Generated by CoffeeScript 1.7.1
(function() {
  angular.module("4treeApp").factory('datasourceTree', [
    '$timeout', 'db_tree', '$rootScope', function($timeout, db_tree, $rootScope) {
      return {
        watchList: [],
        get: function(index, count, success) {
          var i, result, _i, _ref;
          __log.info(index);
          if (index > db_tree._db.tree.length) {
            success([]);
          }
          result = [];
          for (i = _i = index, _ref = index + count - 1; index <= _ref ? _i <= _ref : _i >= _ref; i = index <= _ref ? ++_i : --_i) {
            if (db_tree._db.tree[i]) {
              result.push(db_tree._db.tree[i]);
            }
          }
          return success(result);
        }
      };
    }
  ]);

  angular.module("4treeApp").factory('datasource', [
    '$timeout', '$rootScope', function($timeout, $rootScope) {
      return {
        get: function(index, count, success) {
          var i, result, _i, _ref;
          result = [];
          for (i = _i = index, _ref = index + count - 1; index <= _ref ? _i <= _ref : _i >= _ref; i = index <= _ref ? ++_i : --_i) {
            result.push("{i}");
          }
          return success(result);
        },
        scope2: $rootScope
      };
    }
  ]);

  angular.module("4treeApp").service('db_tree', [
    '$translate', '$http', '$q', '$rootScope', 'oAuth2Api', '$timeout', '$socket', '$location', 'settingsApi', function($translate, $http, $q, $rootScope, oAuth2Api, $timeout, $socket, $location, settingsApi) {
      return {
        _db: {
          texts: {}
        },
        _tmp: {
          _diffs: {}
        },
        _cache: {},
        salt: function() {
          return 'Salt is a mineral substance composed';
        },
        pepper: function() {
          return ' primarily of sodium chloride (NaCl)';
        },
        constructor: function() {
          var mythis;
          mythis = this;
          $rootScope.$on('jsFindAndSaveDiff', function(event, db_name, new_value, old_value) {
            if (new_value && new_value._id) {
              return mythis.saveDiff(db_name, new_value._id);
            }
          });
          $rootScope.$on('my-sorted', function(event, data) {
            return $timeout(function() {
              var element, new_value, old_value;
              __log.info("SORTED", data);
              element = mythis.jsFind(data.from_id);
              old_value = _.clone(element);
              element.parent_id = data.to_id;
              new_value = element;
              $rootScope.$emit("jsFindAndSaveDiff", 'tree', new_value, old_value);
              mythis.refreshParentsIndex();
              return $timeout(function() {
                return $("ul > .tree_tmpl").remove();
              });
            });
          });
          $rootScope.$on('my-created', function(event, data) {
            return __log.info("CREATED", data);
          });
          this.loadTasks();
          if (!this._cache) {
            this._cache = {};
          }
          if (!this._db.tree) {
            this._db.tree = {};
            return this.refreshParentsIndex();
          }
        },
        clearCache: function() {
          _.each(this, function(fn) {
            if (fn) {
              return fn.cache = {};
            }
          });
          return _.each($rootScope.$$childTail.fn.service.calendarBox, function(fn) {
            if (fn) {
              return fn.cache = {};
            }
          });
        },
        getTreeFromeWebOrLocal: function() {
          var dfd, mythis;
          mythis = this;
          this.dbInit();
          dfd = $.Deferred();
          this.ydnLoadFromLocalStorage(mythis).then(function(records) {
            if (!records.tree || Object.keys(records.tree).length === 0) {
              __log.info('NEED DATA FROM NET');
              return mythis.getTreeFromWeb().then(function(data) {
                var result;
                result = {};
                return async.each(Object.keys(data), function(db_name, callback) {
                  records = data[db_name];
                  result[db_name] = records;
                  return mythis.ydnSaveToLocal(db_name, records).then(function() {
                    return callback();
                  });
                }, function() {
                  return dfd.resolve(result);
                });
              });
            } else {
              __log.info('ALL DATA FROM LOCAL');
              return dfd.resolve(records);
            }
          });
          return dfd.promise();
        },
        setMainTimeout: null,
        setMain: function(el) {
          var hash;
          $rootScope.$$childTail.db.main_node[settingsApi.tmp.focus] = el;
          this.setTab(el);
          if (el != null ? el._id : void 0) {
            hash = '' + el._id.substr(el._id.length - 5, el._id.length);
          }
          if (this.setMainTimeout) {
            $timeout.cancel(this.setMainTimeout);
          }
          return this.setMainTimeout = $timeout(function() {
            return $location.hash(hash);
          }, 5000);
        },
        setTab: function(el) {
          var found;
          found = _.find(settingsApi.set.tabs, function(doc) {
            return el._id === doc.tab_id;
          });
          if (!found) {
            return settingsApi.set.tabs.push({
              tab_id: el._id,
              tm: new Date()
            });
          }
        },
        getTreeFromNet: function() {
          var dfd, mythis;
          mythis = this;
          dfd = $q.defer();
          console.time('ALL DATA LOADED');
          this.getTreeFromeWebOrLocal().then(function(records) {
            var found;
            _.each(records, function(data, db_name) {
              var canStoreInThisDB;
              canStoreInThisDB = mythis.dont_store_to_memory.indexOf(db_name) === -1;
              if (canStoreInThisDB) {
                return mythis._db[db_name] = data;
              }
            });
            mythis.refreshParentsIndex();
            settingsApi.tmp.tree_loaded = new Date();
            $rootScope.$$childTail.db.main_node = [];
            $rootScope.$broadcast('tree_loaded');
            if (false) {
              mythis.TestJson();
            }
            if (!$rootScope.$$childTail.db.main_node[settingsApi.tmp.focus]) {
              found = _.find(mythis._db['tree'], function(el) {
                return el.title === '_НОВОЕ';
              });
              mythis.setMain(found);
            }
            mythis.clearCache();
            console.timeEnd('ALL DATA LOADED!');
            return dfd.resolve();
          });
          return dfd.promise;
        },
        getTreeFromWeb: function() {
          var dfd, mythis;
          dfd = $q.defer();
          mythis = this;
          oAuth2Api.jsGetToken().then(function(access_token) {
            return $http({
              url: settingsApi.set.server + '/api/v2/tree',
              method: "GET",
              params: {
                user_id: '5330ff92898a2b63c2f7095f',
                access_token: access_token,
                machine: settingsApi.set.machine
              }
            }).then(function(result) {
              return dfd.resolve(result.data);
            });
          });
          return dfd.promise;
        },
        db: void 0,
        jsSaveElementToLocal: function(db_name, el) {
          var dfd;
          dfd = $.Deferred();
          if (el && el.$$hashKey) {
            delete el.$$hashKey;
          }
          this.db.put(db_name, el).done(function() {
            return dfd.resolve();
          });
          return dfd.promise();
        },
        store_schema: [
          {
            name: 'tree',
            keyPath: '_id',
            autoIncrement: false
          }, {
            name: 'tasks',
            keyPath: '_id',
            autoIncrement: false
          }, {
            name: 'texts',
            keyPath: '_id',
            autoIncrement: false
          }, {
            name: '_diffs',
            keyPath: '_id',
            autoIncrement: false
          }
        ],
        dont_store_to_memory: ['texts'],
        dbInit: function() {
          var options, schema;
          schema = {
            stores: this.store_schema
          };
          options = {};
          this.db = new ydn.db.Storage('_db.tree', schema, options);
          if (false) {
            return this.db.search('name', 'Рабочие').done(function(x) {
              return __log.info('found', x);
            });
          }
        },
        ydnSaveToLocal: function(db_name, records) {
          var dfd, mythis;
          dfd = $.Deferred();
          this.dbInit();
          mythis = this;
          mythis._tmp._diffs = {};
          this.db.clear('_diffs').done(function() {
            return mythis.db.clear(db_name).done(function() {
              return async.eachLimit(Object.keys(records), 200, function(el_name, callback) {
                var el;
                el = records[el_name];
                if (el.$$hashKey) {
                  delete el.$$hashKey;
                }
                return mythis.jsSaveElementToLocal(db_name, el).then(function() {
                  return callback();
                });
              }, function(err) {
                return dfd.resolve();
              });
            });
          });
          return dfd.promise();
        },
        ydnLoadFromLocalStorage: function(mythis) {
          var dfd, result;
          this.dbInit();
          dfd = $.Deferred();
          if (__log.show_time_long) {
            console.time('load_local');
          }
          result = {};
          mythis.db.values('_diffs', null, 999999999).done(function(diffs) {
            _.each(diffs, function(diff) {
              return mythis._tmp._diffs[diff._id] = diff;
            });
            return async.each(mythis.store_schema, function(table_schema, callback) {
              var db_name;
              db_name = table_schema.name;
              if (mythis.dont_store_to_memory.indexOf(db_name) === -1) {
                return mythis.db.values(db_name, null, 999999999).done(function(records) {
                  var data_to_load;
                  if (diffs) {
                    _.each(diffs, function(diff) {
                      var found;
                      found = _.find(records, function(record) {
                        return record._id === diff._id;
                      });
                      if (found && db_name === diff.db_name) {
                        return found = mythis.diff.patch(found, diff.patch);
                      }
                    });
                  }
                  data_to_load = {};
                  _.each(records, function(record) {
                    if (record != null ? record._id : void 0) {
                      return data_to_load[record._id] = record;
                    }
                  });
                  result[db_name] = data_to_load;
                  return callback();
                });
              } else {
                return callback();
              }
            }, function() {
              if (__log.show_time_long) {
                console.timeEnd('load_local');
              }
              dfd.resolve(result);
              return result = void 0;
            });
          });
          return dfd.promise();
        },
        refreshParentsIndex: function(parent_id) {
          var focus, found, mymap, mymap_calendar, myreduce_calendar, mythis;
          focus = settingsApi.tmp.focus;
          mythis = this;
          if (!parent_id) {
            mythis.db_parents = {};
          } else {
            mythis.db_parents['n' + parent_id] = [];
          }
          found = _.find(this._db.tree, function(el) {
            return el.folder === 'main';
          });
          if (found) {
            if (settingsApi.set.main_parent_id.length === 0) {
              settingsApi.set.main_parent_id[0] = found._id;
              settingsApi.set.main_parent_id[1] = found._id;
              settingsApi.set.main_parent_id[2] = found._id;
              settingsApi.set.main_parent_id[3] = found._id;
            }
            settingsApi.set.top_parent_id = found._id;
          }
          _.each(this._db.tree, function(el) {
            var cnt, parent;
            if (parent_id && el.parent_id !== parent_id) {
              return true;
            }
            cnt = [
              {
                title: 'шагов',
                cnt_today: 20,
                days: [
                  {
                    d: '2013-03-01',
                    cnt: 12
                  }, {
                    d: '2013-03-02',
                    cnt: 10
                  }, {
                    d: '2013-03-03',
                    cnt: 8
                  }, {
                    d: '2013-03-05',
                    cnt: 15
                  }, {
                    d: '2013-03-12',
                    cnt: 21
                  }
                ]
              }, {
                title: 'прошёл км.',
                cnt_today: 30,
                days: [
                  {
                    d: '2013-03-01',
                    cnt: 12
                  }, {
                    d: '2013-03-02',
                    cnt: 10
                  }, {
                    d: '2013-03-03',
                    cnt: 8
                  }, {
                    d: '2013-03-05',
                    cnt: 15
                  }, {
                    d: '2013-03-12',
                    cnt: 21
                  }
                ]
              }, {
                title: 'отжиманий',
                cnt_today: 19,
                days: [
                  {
                    d: '2013-03-01',
                    cnt: 12
                  }, {
                    d: '2013-03-02',
                    cnt: 10
                  }, {
                    d: '2013-03-03',
                    cnt: 8
                  }, {
                    d: '2013-03-05',
                    cnt: 15
                  }, {
                    d: '2013-03-12',
                    cnt: 21
                  }
                ]
              }
            ];
            if (el._id && el._id !== 1) {
              el._path = mythis.jsGetPath(el._id);
            }
            el.importance = el.importance ? el.importance : 50;
            el.tags = el.tags ? el.tags : [];
            if (!el.counters) {
              el.counters = cnt;
            }
            if (!el._panel) {
              el._panel = [
                {
                  _open: false
                }, {
                  _open: false
                }, {
                  _open: false
                }, {
                  _open: false
                }
              ];
            }
            if (false) {
              el.dates = {
                startDate: el.dates ? moment(el.dates.startDate) : "",
                endDate: el.dates ? moment(el.dates.endDate) : ""
              };
            }
            parent = 'n' + el.parent_id;
            if (!mythis.db_parents[parent]) {
              mythis.db_parents[parent] = [];
            }
            mythis.db_parents[parent].push(el);
            return true;
          });
          _.each(mythis._db.tree, function(el, key) {
            var parent;
            parent = 'n' + el._id;
            if (mythis.db_parents[parent]) {
              el._childs = mythis.db_parents[parent].length;
            } else {
              el._childs = 0;
              el._open = false;
            }
            return true;
          });
          mythis.clearCache();
          true;
          mymap = function(doc, emit) {
            if (doc.text && doc.text.indexOf('жопа') !== -1) {
              return emit(doc.date, doc.title, doc);
            }
          };
          mymap_calendar = function(doc, emit) {
            if (((doc != null ? doc.date2 : void 0) || (doc != null ? doc.date1 : void 0)) && (doc != null ? doc.date_on : void 0) && !(doc != null ? doc.hide_in_todo : void 0)) {
              return emit(doc.date1, doc, doc);
            }
          };
          myreduce_calendar = function(memo, values) {
            var day, day1, day2, days, key, _results;
            key = values.key;
            key = moment(values.key);
            key = key.format("YYYY-MM-DD");
            day1 = new Date(values.value.date1).getTime();
            day2 = new Date(values.value.date2).getTime();
            days = (day2 - day1) / (24 * 60 * 60 * 1000);
            if (days > 0) {
              _results = [];
              while ((days--) > 0) {
                day = day1 + days * 24 * 60 * 60 * 1000;
                key = moment(new Date(day));
                key = key.format("YYYY-MM-DD");
                if (!memo[key]) {
                  memo[key] = [];
                }
                if (values.value) {
                  _results.push(memo[key].push(values.value));
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            }
          };
          this.newView('tasks', 'tasks_by_date', mymap_calendar, myreduce_calendar);
          mymap_calendar = function(doc, emit) {
            if ((doc != null ? doc.tree_id : void 0)) {
              return emit(doc.tree_id, doc, doc);
            }
          };
          myreduce_calendar = function(memo, values) {
            var key, sorted;
            key = values.key;
            if (!memo[key]) {
              memo[key] = {
                tasks: [],
                next_action: [],
                cnt: 0
              };
            }
            if (values.value) {
              memo[key].tasks.push(values.value);
            }
            if (memo[key].tasks) {
              memo[key].cnt = memo[key].tasks.length;
            }
            if (memo[key].cnt > 0) {
              sorted = mythis.sortTasks(memo[key].tasks);
            }
            memo[key].tasks = sorted;
            return memo[key].next_action = mythis.getNextAction(sorted);
          };
          mythis.newView('tasks', 'tasks_by_tree_id', mymap_calendar, myreduce_calendar);
        },
        getTree: function(args) {
          return this._db.tree;
        },
        jsFindByParent: _.memoize(function(args) {
          var elements;
          elements = _.sortBy(this.db_parents['n' + args], function(value, key) {
            return value.pos;
          });
          return elements = _.filter(elements, function(value) {
            return value.del !== 1;
          });
        }, function(args) {
          return args + ' ' + settingsApi.tmp.tree_loaded;
        }),
        'web_tags': [
          {
            id: 1,
            parent: 0,
            title: "Кулинария",
            cnt: 1
          }, {
            id: 5,
            parent: 1,
            title: "Супы",
            cnt: 6
          }, {
            id: 7,
            parent: 5,
            title: "Диетические",
            cnt: 1
          }, {
            id: 8,
            parent: 5,
            title: "Фруктовые",
            cnt: 3
          }, {
            id: 6,
            parent: 1,
            title: "Каши",
            cnt: 3
          }, {
            id: 2,
            parent: 0,
            title: "Рукоделие",
            cnt: 1
          }, {
            id: 9,
            parent: 2,
            title: "Холодный фарфор",
            cnt: 2
          }, {
            id: 10,
            parent: 2,
            title: "Тильда",
            cnt: 0
          }, {
            id: 10,
            parent: 2,
            title: "Скрапбукинг",
            cnt: 1
          }, {
            id: 10,
            parent: 2,
            title: "Канзаши",
            cnt: 3
          }, {
            id: 10,
            parent: 2,
            title: "Бисероплетение",
            cnt: 211
          }, {
            id: 10,
            parent: 2,
            title: "Вязание",
            cnt: 1
          }, {
            id: 3,
            parent: 0,
            title: "Мои новости",
            cnt: 8
          }, {
            id: 4,
            parent: 0,
            title: "Я в лицах",
            cnt: 11
          }
        ],
        tree_tags: [
          {
            id: 1,
            parent: 0,
            title: "GTD",
            cnt: 0
          }, {
            id: 4,
            parent: 1,
            title: "Входящие",
            cnt: 12
          }, {
            id: 2,
            parent: 1,
            title: "Следующие действия",
            cnt: 4
          }, {
            id: 3,
            parent: 1,
            title: "Когда-нибудь",
            cnt: 24
          }, {
            id: 5,
            parent: 1,
            title: "Календарь",
            cnt: 120
          }, {
            id: 6,
            parent: 1,
            title: "Ожидание",
            cnt: 8
          }, {
            id: 7,
            parent: 1,
            title: "Проект",
            cnt: 3
          }, {
            id: 8,
            parent: 0,
            title: "Рабочие дела",
            cnt: 4
          }, {
            id: 9,
            parent: 0,
            title: "Домашние дела",
            cnt: 8
          }, {
            id: 10,
            parent: 0,
            title: "Мой сайт",
            cnt: 18
          }, {
            id: 11,
            parent: 0,
            title: "Чтение",
            cnt: 0
          }, {
            id: 12,
            parent: 11,
            title: "Почитать",
            cnt: 2
          }, {
            id: 13,
            parent: 11,
            title: "Прочитано",
            cnt: 243
          }
        ],
        jsFindByParentWeb: function(args) {
          return _.filter(this.web_tags, function(el) {
            return el.parent_id === args;
          });
        },
        jsFindByParentTags: function(args) {
          return _.filter(this.tree_tags, function(el) {
            return el.parent_id === args;
          });
        },
        'first_element': {
          title: '4tree',
          parent_id: '0',
          _path: ['2']
        },
        'jsFind': function(id) {
          var found, _ref, _ref1;
          if (id === 1) {
            return this.first_element;
          }
          if ((_ref = this._db) != null ? (_ref1 = _ref['tree']) != null ? _ref1[id] : void 0 : void 0) {
            found = this._db['tree'][id];
          }
          if (id === void 0) {
            return void 0;
          }
          return found;
        },
        'jsGetPath': _.memoize(function(id) {
          var el, path, prevent_recursive;
          if (id === 1 || id === 0) {
            return ['100'];
          }
          path = [];
          prevent_recursive = 1000;
          while ((el = this.jsFind(id)) && (prevent_recursive--)) {
            id = el.parent_id;
            if (el.parent_id) {
              path.push(el._id);
            }
          }
          path.push(settingsApi.set.top_parent_id);
          return path.reverse();
        }),
        jsView: function() {
          return this._cache;
        },
        newView: function(db_name, view_name, mymap, myreduce) {
          var mythis;
          mythis = this;
          if (!mythis._cache[db_name]) {
            mythis._cache[db_name] = {};
          }
          if (!mythis._cache[db_name]['views']) {
            mythis._cache[db_name]['views'] = {};
          }
          if (!mythis._cache[db_name]['views'][view_name]) {
            return mythis._cache[db_name]['views'][view_name] = {
              rows: [],
              invalid: [],
              'map': mymap,
              'reduce': myreduce
            };
          }
        },
        getView: function(db_name, view_name) {
          var view;
          view = this._cache[db_name]['views'][view_name];
          if (view && view.rows) {
            if (view.rows.length && view.invalid.length === 0) {
              return view;
            } else if (view.invalid.length > 0 && view.rows.length > 0) {
              this.generateView(db_name, view_name, view.invalid);
              return view;
            } else {
              this.generateView(db_name, view_name);
              return view;
            }
          } else {
            console.info('NOT FOUND VIEW', db_name, view_name);
          }
        },
        generateView: function(db_name, view_name, view_invalid) {
          var emit, memo, myrows, view;
          view = this._cache[db_name]['views'][view_name];
          if ((view_invalid != null ? view_invalid[0] : void 0) === 0) {
            view_invalid = false;
          }
          if (view_invalid) {
            myrows = [
              _.find(this._db[db_name], function(el) {
                return view_invalid.indexOf(el._id) !== -1;
              })
            ];
            view.rows = _.filter(view.rows, function(el) {
              return view_invalid.indexOf(el._id) === -1;
            });
          } else {
            myrows = this._db[db_name];
          }
          memo = {};
          emit = function(key, value, doc) {
            if (!view.rows) {
              view.rows = [];
            }
            view.rows.push({
              _id: doc._id,
              key: key,
              value: value
            });
            if (!view_invalid && view['reduce']) {
              return view['reduce'](memo, {
                key: key,
                value: value
              });
            }
          };
          _.each(myrows, function(doc, key) {
            var result;
            return result = view['map'](doc, emit);
          });
          if (view_invalid && view['reduce']) {
            _.each(view.rows, function(doc) {
              return view['reduce'](memo, {
                key: doc.key,
                value: doc.value
              });
            });
          }
          view.rows = _.sortBy(view.rows, function(el) {
            return el.key;
          });
          view.invalid = [];
          return view.result = memo;
        },
        refreshView: function(db_name, ids, new_value, old_value) {
          var mythis;
          mythis = this;
          _.each(ids, function(id) {
            var _ref;
            return _.each((_ref = mythis._cache[db_name]) != null ? _ref.views : void 0, function(view) {
              return view.invalid.push(id);
            });
          });
          return this.clearCache();
        },
        loadTasks: function() {
          return true;
        },
        clearCache2: function() {
          return _.each(this, function(fn) {
            if (fn && fn.cache) {
              return fn.cache = {};
            }
          });
        },
        getTasks: function() {
          return this._db.tasks;
        },
        calcWeight: function(el) {
          var mythis, round, w, weight, weight_date, weight_importance, _ref, _ref1, _ref2;
          mythis = this;
          round = function(value) {
            return Math.round(parseInt(value * 100)) / 100;
          };
          weight_date = settingsApi.set.weight.date;
          weight_importance = settingsApi.set.weight.importance;
          w = {};
          w['tree_id'] = (_ref = mythis._db) != null ? (_ref1 = _ref.tree) != null ? (_ref2 = _ref1[el.tree_id]) != null ? _ref2.importance : void 0 : void 0 : void 0;
          w['did'] = 0;
          w['created'] = (new Date(el.created).getTime() - settingsApi.set.today_date_time) / (24 * 60 * 60 * 1000 * 10);
          if (!!el.did) {
            w['did'] = -50000;
          }
          if (el.date2) {
            w['date1'] = (new Date(el.date2).getTime() - settingsApi.set.today_date_time) / (24 * 60 * 60 * 1000);
          } else {
            w['date1'] = -500;
            w['importance'] = (el.importance ? el.importance : 50) * weight_importance;
          }
          weight = _.reduce(w, function(memo, el) {
            return memo + el;
          });
          return {
            weights: w,
            weight: weight
          };
        },
        pad: function(str, max) {
          str = str.toString();
          if (str.length < max) {
            return pad("0" + str, max);
          } else {
            return str;
          }
        },
        sortTasks: function(answer, order_type) {
          var mythis;
          if (order_type == null) {
            order_type = 'by_priority_and_date';
          }
          mythis = this;
          if (order_type === 'by_priority_and_date') {
            answer = _.sortBy(answer, function(el) {
              var w;
              w = mythis.calcWeight(el);
              return -w.weight;
            });
          }
          return answer;
        },
        getNextAction: function(answer) {
          var na, na2, na3, na_date, today, _ref;
          today = new Date();
          na = [];
          na2 = [];
          na3 = [];
          _.each(answer, function(el) {
            var el_date, na_date, _ref;
            if (!el.did) {
              if (!na2.length && !el.date1) {
                na2 = [el];
              }
              if (!na.length) {
                na = [el];
              }
              el_date = new Date(el.date1);
              na_date = new Date(na != null ? (_ref = na[0]) != null ? _ref.date1 : void 0 : void 0);
              if (el.date1 && (el_date < na_date) && (el_date <= today)) {
                na = [el];
              }
              if (el.date1 && (el_date < na_date) && (el_date > today)) {
                return na3 = [el];
              }
            }
          });
          na_date = new Date(na != null ? (_ref = na[0]) != null ? _ref.date1 : void 0 : void 0);
          if ((!na.length || (na.length && na_date > today)) && na2.length) {
            na = na2;
          }
          if (!na.length && !na2.length && na3.length && false) {
            na = na3;
          }
          return na;
        },
        jsExpand: function(id, make_open) {
          var focus;
          if (__log.show_time_long) {
            console.time('expand');
          }
          focus = settingsApi.tmp.focus;
          _.each(this._db.tree, function(el) {
            if (el._path && el._path.indexOf(id) !== -1) {
              if (!(make_open === true && el._childs > 50)) {
                if (el._childs > 0) {
                  el._panel[focus]._open = make_open;
                }
              } else {
                el._open = void 0;
              }
            }
          });
          if (__log.show_time_long) {
            return console.timeEnd('expand');
          }
        },
        tree_template: function() {
          return {
            title: '',
            parent_id: '',
            _id: ''
          };
        },
        task_template: function() {
          return {
            title: '',
            parent_id: '',
            _id: ''
          };
        },
        getIcon: function(tree) {
          if (!tree.icon) {
            return 'icon-heart-empty';
          } else {
            return tree.icon;
          }
        },
        diffForSort: function(tree) {
          var found, parents, sortPrice;
          parents = this.db_parents['n' + tree.parent_id];
          parents = _.sortBy(parents, function(value) {
            return value.pos;
          });
          found = _.find(parents, function(value) {
            return value.pos > tree.pos;
          });
          if (found && found.pos) {
            __log.info("POS = ", found.pos, tree.pos);
            sortPrice = (parseInt(1000000000000 * (found.pos - tree.pos) / 1.1)) / 1000000000000;
            return sortPrice;
          } else {
            return 1;
          }
        },
        jsAddNote: function(tree, make_child) {
          var focus, new_note;
          focus = settingsApi.tmp.focus;
          __log.info("AddNote", tree);
          new_note = new this.tree_template;
          new_note.title = settingsApi.set.new_title;
          new_note._id = new ObjectId().toString();
          new_note['_new'] = true;
          new_note._focus_me = true;
          new_note.user_id = settingsApi.set.user_id;
          new_note.pos = tree.pos + this.diffForSort(tree);
          this._db.tree[new_note._id] = new_note;
          if (!make_child) {
            new_note.parent_id = tree.parent_id;
            this.refreshParentsIndex(tree.parent_id);
          } else {
            new_note.parent_id = tree._id;
            this.refreshParentsIndex();
            tree._open = true;
          }
          this.main_node(new_note);
          return this.clearCache();
        },
        jsAddTask: function(event, scope, tree) {
          var mythis, new_task, new_value, old_value, tree_id;
          event.stopPropagation();
          event.preventDefault();
          mythis = $rootScope.$$childTail.fn.service.db_tree;
          __log.info('add_task', event, scope, tree);
          tree_id = scope.db.main_node[scope.tmp.focus_edit]._id;
          if (tree_id) {
            new_task = new mythis.task_template;
            new_task._id = new ObjectId().toString();
            new_task.tree_id = tree_id;
            new_task.parent_id = tree_id;
            new_task._new = true;
            new_task.created = new Date();
            new_task.importance = 50;
            new_task.user_id = settingsApi.set.user_id;
            old_value = _.clone(new_task);
            new_task.title = scope.new_task_title;
            if (!mythis._db.tasks[new_task._id]) {
              mythis._db.tasks[new_task._id] = new_task;
            }
            __log.info('pushed new task', new_task);
            scope.new_task_title = "";
            mythis.clearCache();
            new_value = new_task;
            return $rootScope.$emit("jsFindAndSaveDiff", 'tasks', new_value, old_value);
          }
        },
        jsEnterPress: function(event, scope, tree) {
          return event.target.blur();
        },
        jsBlur: function(event, scope, tree) {
          if (false) {
            return tree['_new'] = false;
          }
        },
        jsFindPreviusParent: function(tree) {
          var found, parents;
          parents = $rootScope.$$childTail.fn.service.db_tree.db_parents['n' + tree.parent_id];
          parents = _.sortBy(parents, function(value) {
            return value.pos;
          });
          found = _.filter(parents, function(value) {
            return value.pos < tree.pos;
          });
          return found = found[found.length - 1];
        },
        jsEscPress: function(event, scope) {
          var focus, prev_note;
          focus = settingsApi.tmp.focus;
          prev_note = $rootScope.$$childTail.fn.service.db_tree.jsFindPreviusParent(scope.tree);
          if (scope.tree['_new']) {
            scope.tree.del = 1;
          }
          if (prev_note) {
            this.setMain(prev_note);
          }
          return event.target.blur();
        },
        findMaxPos: function(prev_note_id) {
          var parents;
          parents = $rootScope.$$childTail.fn.service.db_tree.db_parents['n' + prev_note_id];
          parents = _.sortBy(parents, function(value) {
            return value.pos;
          });
          if (parents.length) {
            return parents[parents.length - 1].pos + 1;
          } else {
            return 1;
          }
        },
        jsTabPress: function(event, scope, tree) {
          var db_tree, focus, main_node, parent_note, prev_note, shift;
          focus = settingsApi.tmp.focus;
          db_tree = $rootScope.$$childTail.fn.service.db_tree;
          if (db_tree.jsIsTree()) {
            event.stopPropagation();
            event.preventDefault();
            main_node = $rootScope.$$childTail.db.main_node[focus];
            __log.info(main_node);
            shift = event.shiftKey;
            if (!shift) {
              prev_note = db_tree.jsFindPreviusParent(main_node);
              if (prev_note) {
                prev_note._panel[focus]._open = true;
                main_node.parent_id = prev_note._id;
                main_node.pos = db_tree.findMaxPos(prev_note._id);
                main_node._focus_me = true;
                return db_tree.refreshParentsIndex();
              }
            } else {
              parent_note = db_tree.jsFind(main_node.parent_id);
              __log.info({
                parent_note: parent_note
              });
              if (parent_note && parent_note.folder !== 'main') {
                main_node.parent_id = parent_note.parent_id;
                main_node.pos = parent_note.pos + db_tree.diffForSort(parent_note);
                main_node._focus_me = true;
                return db_tree.refreshParentsIndex();
              }
            }
          }
        },
        jsFindNext: function(tree, ignore_open) {
          var db_tree, focus, found, found_key, next, parents;
          focus = settingsApi.tmp.focus;
          db_tree = $rootScope.$$childTail.fn.service.db_tree;
          if (tree && tree._panel[focus]._open && !ignore_open) {
            if (db_tree.db_parents['n' + tree._id]) {
              found = db_tree.db_parents['n' + tree._id][0];
            }
            return found;
          }
          parents = db_tree.db_parents['n' + tree.parent_id];
          parents = _.sortBy(parents, function(value) {
            return value.pos;
          });
          found_key = 0;
          found = _.find(parents, function(value, key) {
            if (value._id === tree._id) {
              found_key = key;
            }
            return value._id === tree._id;
          });
          found = parents[found_key + 1];
          if (!found) {
            __log.info('need_to_parent');
            next = db_tree.jsFind(tree.parent_id);
            if (next) {
              found = db_tree.jsFindNext(next, 'ignore_open');
            }
          }
          return found;
        },
        jsFindPrev: function(tree, ignore_open, last_and_deep) {
          var db_tree, focus, found, found_key, parents;
          focus = settingsApi.tmp.focus;
          db_tree = $rootScope.$$childTail.fn.service.db_tree;
          if ((tree && tree._open2 && !ignore_open) || last_and_deep) {
            parents = db_tree.db_parents['n' + tree._id];
            found = parents[parents.length - 1];
            if (last_and_deep && found._open) {
              return db_tree.jsFindPrev(found, 'true', 'last_and_deep');
            } else {
              return found;
            }
          }
          parents = db_tree.db_parents['n' + tree.parent_id];
          parents = _.sortBy(parents, function(value) {
            return value.pos;
          });
          found_key = 0;
          found = _.find(parents, function(value, key) {
            if (value._id === tree._id) {
              found_key = key;
            }
            return value._id === tree._id;
          });
          found = parents[found_key - 1];
          if (found && found._panel[focus]._open) {
            found = db_tree.jsFindPrev(db_tree.jsFind(found._id), 'ignore_open', 'last_and_deep');
          }
          if (!found && !ignore_open && !last_and_deep) {
            if (tree.parent_id !== settingsApi.set.main_parent_id[focus]) {
              found = db_tree.jsFind(tree.parent_id);
            }
          }
          return found;
        },
        jsIsTree: function() {
          var focus, widget_index;
          focus = settingsApi.tmp.focus;
          widget_index = settingsApi.set._panel[focus].active;
          if ([0].indexOf(widget_index) !== -1) {
            return true;
          } else {
            return false;
          }
        },
        jsUpPress: function(event, scope) {
          var db_tree, focus, found;
          focus = settingsApi.tmp.focus;
          db_tree = $rootScope.$$childTail.fn.service.db_tree;
          if (db_tree.jsIsTree()) {
            event.stopPropagation();
            event.preventDefault();
            found = db_tree.jsFindPrev($rootScope.$$childTail.db.main_node[focus]);
            if (found) {
              return this.setMain(found);
            }
          }
        },
        jsDownPress: function(event, scope) {
          var db_tree, focus, found;
          focus = settingsApi.tmp.focus;
          db_tree = $rootScope.$$childTail.fn.service.db_tree;
          if (db_tree.jsIsTree()) {
            event.stopPropagation();
            event.preventDefault();
            found = db_tree.jsFindNext($rootScope.$$childTail.db.main_node[focus]);
            if (found) {
              return this.setMain(found);
            }
          }
        },
        jsLeftPress: function(event, scope) {
          var db_tree, focus;
          focus = settingsApi.tmp.focus;
          db_tree = $rootScope.$$childTail.fn.service.db_tree;
          if (db_tree.jsIsTree()) {
            event.stopPropagation();
            event.preventDefault();
            if ($rootScope.$$childTail.db.main_node[focus]._panel[focus]._open) {
              return $rootScope.$$childTail.db.main_node[focus]._panel[focus]._open = false;
            } else {
              return true;
            }
          }
        },
        jsRightPress: function(event, scope) {
          var db_tree, focus;
          focus = settingsApi.tmp.focus;
          db_tree = $rootScope.$$childTail.fn.service.db_tree;
          if (db_tree.jsIsTree()) {
            event.stopPropagation();
            event.preventDefault();
            if (!$rootScope.$$childTail.db.main_node[focus]._panel[focus]._open) {
              return $rootScope.$$childTail.db.main_node[focus]._panel[focus]._open = true;
            } else {
              return true;
            }
          }
        },
        jsFocus1: function() {
          return settingsApi.tmp.focus = 0;
        },
        jsFocus2: function() {
          return settingsApi.tmp.focus = 1;
        },
        jsFocus3: function() {
          return settingsApi.tmp.focus = 2;
        },
        jsFocus4: function() {
          return settingsApi.tmp.focus = 3;
        },
        searchString: function(searchString, dont_need_highlight) {
          var dfd;
          dfd = new $.Deferred();
          __log.info('search', searchString);
          oAuth2Api.jsGetToken().then(function(access_token) {
            return $http({
              url: settingsApi.set.server + '/api/v1/search',
              method: "GET",
              params: {
                user_id: '5330ff92898a2b63c2f7095f',
                access_token: access_token,
                search: searchString,
                machine: settingsApi.set.machine,
                dont_need_highlight: dont_need_highlight
              }
            }).then(function(result) {
              return dfd.resolve(result.data);
            });
          });
          return dfd.promise();
        },
        jsTreeToDiary: function(tree_el) {
          return tree_el.diary = new Date();
        },
        diaryFind: _.memoize(function(date) {
          var answer, key, mymap_diary, myreduce_diary, mythis;
          mythis = this;
          mymap_diary = function(doc, emit) {
            if (doc != null ? doc.diary : void 0) {
              return emit(doc.diary, doc, doc);
            }
          };
          myreduce_diary = function(memo, values) {
            var key;
            key = values.key;
            key = moment(values.key);
            key = key.format("YYYY-MM-DD");
            if (!memo[key]) {
              memo[key] = [];
            }
            if (values.value) {
              return memo[key].push(values.value);
            }
          };
          this.newView('tree', 'diary_by_date', mymap_diary, myreduce_diary);
          key = moment(date).format('YYYY-MM-DD');
          answer = mythis.getView('tree', 'diary_by_date').result[key];
          if (answer) {
            __log.info(answer, date, answer.text);
          }
          return answer;
        }),
        diff: jsondiffpatch.create({
          objectHash: function(obj) {
            return obj.name || obj.id || obj._id || obj._id || JSON.stringify(obj);
          },
          textDiff: {
            minLength: 3
          }
        }),
        dfdTextLater: $q.defer(),
        getTextLater: _.throttle(function(text_id) {
          var mythis;
          mythis = this;
          $timeout(function() {
            return mythis.getText(text_id).then(function(text_element) {
              if (text_element) {
                return mythis.dfdTextLater.resolve(text_element);
              } else {
                __log.info('text_not_found');
                return mythis.dfdTextLater.resolve();
              }
            });
          }, 1000);
          return mythis.dfdTextLater.promise;
        }, 3000),
        getTextFromDB: function(text_id) {
          var dfd, mythis, patch_found;
          mythis = this;
          dfd = $q.defer();
          patch_found = mythis._tmp._diffs[text_id];
          mythis.db.get('texts', text_id).done(function(found) {
            var new_text;
            if (found) {
              if (patch_found) {
                new_text = mythis.diff.patch({
                  txt: found.text
                }, patch_found.patch);
              }
              if (new_text) {
                found.text = new_text.txt.toString();
              }
              dfd.resolve(found);
            } else {
              mythis.getTextLater(text_id).then(function(text_element) {
                return dfd.resolve(text_element);
              });
            }
          });
          return;
          return dfd.promise;
        },
        getText: function(text_id) {
          var dfd, mythis;
          mythis = this;
          dfd = $q.defer();
          this.getElement('texts', text_id).then(function(text_element) {
            return dfd.resolve(text_element);
          });
          return dfd.promise;
        },
        setText: function(text_id, new_text) {
          var doc, found, mythis;
          mythis = this;
          found = this._db['texts'][text_id];
          if (found) {
            found.text = new_text;
            return mythis.saveDiff('texts', text_id);
          } else {
            if (text_id && new_text.length) {
              doc = {
                _id: text_id,
                _tm: new Date(),
                db_name: 'trees',
                text: new_text,
                user_id: settingsApi.set.user_id,
                del: 0,
                _new: true
              };
              doc._sha1 = mythis.JSON_stringify(doc)._sha1;
              this._db['texts'][text_id] = doc;
              return mythis.db.put('texts', doc).done(function() {
                return __log.info('text ' + text_id + ' saved', doc);
              });
            }
          }
        },
        'jsStartSyncInWhile': _.debounce(function() {
          if (false || settingsApi.set.autosync_on) {
            return this.syncDiff();
          }
        }, 1000),
        'jsStartSyncRightNow': _.debounce(function() {
          if (false || settingsApi.set.autosync_on) {
            return this.syncDiff();
          }
        }, 10),
        saveDiff: _.throttle(function(db_name, _id) {
          var dfd, mythis;
          mythis = this;
          dfd = $q.defer();
          this.getElement(db_name, _id).then(function(new_element) {
            mythis.getElementFromLocal(db_name, _id).then(function(old_element) {
              var el, patch;
              if (new_element && old_element) {
                patch = mythis.diff.diff(old_element, new_element);
                if (patch && patch._sha1) {
                  delete patch._sha1;
                }
                if (patch && patch._tm) {
                  delete patch._tm;
                }
                if (patch) {
                  _.each(Object.keys(patch), function(key) {
                    if (patch[key] && (key[0] === '_' || key[0] === '$')) {
                      return delete patch[key];
                    }
                  });
                }
                el = {
                  _id: _id,
                  patch: patch,
                  db_name: db_name,
                  _sha1: old_element._sha1,
                  user_id: settingsApi.set.user_id,
                  machine: settingsApi.set.machine,
                  _tm: new Date().getTime()
                };
                if (patch && !_.isEmpty(patch)) {
                  mythis._tmp._diffs[el._id] = el;
                  return mythis.db.put('_diffs', el).done(function() {
                    dfd.resolve();
                    mythis.jsStartSyncInWhile();
                    $('.sync').addClass('need_sync');
                    return mythis.refreshView(db_name, [new_element._id]);
                  });
                }
              } else {
                if (new_element && new_element._new === true) {
                  dfd.resolve();
                  mythis.jsStartSyncInWhile();
                  $('.sync').addClass('need_sync');
                  return mythis.refreshView(db_name, [new_element._id]);
                }
              }
            });
            return;
          });
          return dfd.promise;
        }, 50),
        getElementFromLocalPlusDiffs: function(db_name, _id) {
          var dfd, mythis;
          dfd = $q.defer();
          mythis = this;
          this.getElementFromLocal(db_name, _id).then(function(result) {
            var diff;
            diff = mythis._tmp._diffs[_id];
            if (diff && diff._id && diff.db_name === db_name) {
              result = mythis.diff.patch(result, diff.patch);
              dfd.resolve(result);
            } else {
              dfd.resolve(result);
            }
          });
          return dfd.promise;
        },
        getElementFromLocal: function(db_name, _id) {
          var dfd, mythis;
          mythis = this;
          dfd = $q.defer();
          this.db.get(db_name, _id).done(function(result) {
            return dfd.resolve(result);
          });
          return dfd.promise;
        },
        getElement: function(db_name, _id) {
          var dfd, found, mythis, _ref, _ref1;
          mythis = this;
          dfd = $q.defer();
          if (!_id) {
            dfd.resolve();
            return dfd.promise;
          }
          found = (_ref = this._db) != null ? (_ref1 = _ref[db_name]) != null ? _ref1[_id] : void 0 : void 0;
          if (!found && _id) {
            mythis.getElementFromLocalPlusDiffs(db_name, _id).then(function(found) {
              if (found) {
                mythis._db[db_name][found._id] = found;
              }
              return dfd.resolve(found);
            });
          } else {
            dfd.resolve(found);
          }
          return dfd.promise;
        },
        tmp_set: function(_id) {
          var dfd, mythis;
          mythis = this;
          dfd = $q.defer();
          mythis.getElement('texts', _id).then(function(result) {
            mythis._db['texts'][_id].text = result.text + '<p>' + Math.round(Math.random() * 100) + '</p>';
            __log.info('ADDED ', mythis._db['texts'][_id].text);
            return mythis.saveDiff('texts', _id).then(function() {
              return dfd.resolve();
            });
          });
          return dfd.promise;
        },
        copyObject: function(source, obj) {
          var key, newObj;
          newObj = source;
          for (key in obj) {
            newObj[key] = obj[key];
          }
          return newObj;
        },
        syncApplyResults: function(results) {
          var dfd, mythis;
          dfd = $q.defer();
          mythis = this;
          __log.debug('syncApply', 'Начинаю применять результаты синхронизации', {});
          if (mythis.before_sync && mythis.before_sync.length) {
            __log.debug('syncApply', 'Есть сохранённые бекапы элементов', {
              before_sync: mythis.before_sync
            });
          }
          mythis.clearCache();
          _.each(Object.keys(results), function(db_name) {
            var db_data;
            db_data = results[db_name];
            if (db_data && _.isObject(db_data.not_found)) {
              _.each(Object.keys(db_data.not_found), function(not_found) {
                var sha1_of_not_found;
                sha1_of_not_found = db_data.not_found[not_found];
                console.error('NEED RESEND ALL ELEMENT NEXT TIME', not_found, sha1_of_not_found);
                if (!mythis._tmp._send_doc_next_time) {
                  mythis._tmp._send_doc_next_time = {};
                }
                if (!mythis._tmp._send_doc_next_time[db_name]) {
                  mythis._tmp._send_doc_next_time[db_name] = {};
                }
                return mythis._tmp._send_doc_next_time[db_name][not_found] = sha1_of_not_found;
              });
            }
            if (db_data && _.isObject(db_data.confirm)) {
              return _.each(Object.keys(db_data.confirm), function(confirm_id) {
                var confirm_element;
                confirm_element = db_data.confirm[confirm_id];
                __log.debug('syncApply', 'Применяю первое подтверждение для ' + confirm_id, {
                  confirm_element: confirm_element
                });
                __log.debug('syncApply', 'Мне прислали _sha1 = ' + confirm_element._sha1, {});
                return mythis.getElement(db_name, confirm_id).then(function(doc) {
                  var el, machine_id, old_doc, patch, sha1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
                  if (doc) {
                    __log.debug('syncApply', 'В своей базе (+patch) я нашёл _sha1 = ' + doc._sha1, {
                      doc: doc
                    });
                    if (doc._new) {
                      doc._new = false;
                      __log.debug('syncApply', 'Элемент в базе был новым, я его отметил старым', {});
                    }
                    sha1 = mythis.JSON_stringify(doc)._sha1;
                    __log.debug('syncApply', 'Вычислил актуальный _sha1 = ' + sha1, {
                      doc: doc
                    });
                    if (sha1 === confirm_element._sha1) {
                      __log.debug('syncApply', '_sha1 ' + sha1 + ' совпали, всё в порядке', {});
                      doc._sha1 = confirm_element._sha1;
                      __log.debug('syncApply', '_sha1 совпали, присваиваю doc._sha1 = ' + confirm_element._sha1, {
                        confirm_element: confirm_element,
                        doc: doc
                      });
                      doc._tm = confirm_element._tm;
                      __log.debug('syncApply', '_sha1 совпали, обновил _tm и sha1 и сохраняю в базу', {
                        doc: doc
                      });
                      mythis.db.put(db_name, doc).done(function(err) {
                        __log.info('new data applyed', err, doc);
                        return __log.debug('syncApply', '_sha1 совпали. Сохранил в базу данных ' + doc._sha1, {
                          err: err,
                          doc: doc
                        });
                      });
                      __log.debug('syncApply', '_sha1 совпали. Удалил локальные дифы. ', {});
                      if (mythis._tmp._diffs[confirm_id]) {
                        delete mythis._tmp._diffs[confirm_id];
                      }
                      if ((_ref = mythis._tmp) != null ? (_ref1 = _ref._send_doc_next_time) != null ? (_ref2 = _ref1[db_name]) != null ? _ref2[confirm_id] : void 0 : void 0 : void 0) {
                        delete mythis._tmp._send_doc_next_time[db_name][confirm_id];
                      }
                      return mythis.db.remove('_diffs', confirm_id).done(function(err) {
                        __log.debug('syncApply', '_sha1 совпали. Удалил дифы в базе ', {
                          err: err
                        });
                        return dfd.resolve();
                      });
                    } else {
                      __log.debug('syncApply', '!= _sha1 sha1 в базе не совпадает с присланным с сервера ' + sha1 + ' != (сервер)' + confirm_element._sha1, {
                        doc: doc,
                        confirm_element: confirm_element
                      });
                      old_doc = mythis.before_sync[doc._id];
                      if (old_doc) {
                        __log.debug('syncApply', '!= Нашел элемент в бекапе _sha1 = ' + (old_doc != null ? old_doc._sha1 : void 0), {
                          old_doc: old_doc
                        });
                      }
                      __log.debug('EMPTY DOC RECIEVED!!! STRANGE');
                      if (confirm_element._doc) {
                        doc = confirm_element._doc;
                        __log.debug('syncApply', '!= С сервера прислали документ целиком, беру его. _sha1 = ' + doc._sha1, {
                          doc: doc
                        });
                        if (!old_doc || confirm_element.merged) {
                          __log.debug('Прислали документ с мерджем!', confirm_element);
                          machine_id = settingsApi.set.machine;
                          if (confirm_element.merged && machine_id === '7829517') {
                            alert('merged');
                          }
                          if (mythis._tmp._diffs[confirm_id]) {
                            delete mythis._tmp._diffs[confirm_id];
                          }
                          if ((_ref3 = mythis._tmp) != null ? (_ref4 = _ref3._send_doc_next_time) != null ? (_ref5 = _ref4[db_name]) != null ? _ref5[confirm_id] : void 0 : void 0 : void 0) {
                            delete mythis._tmp._send_doc_next_time[db_name][confirm_id];
                          }
                          mythis.db.remove('_diffs', confirm_id).done(function(err) {
                            return __log.debug('syncApply', '_sha1 не совпали. Удалил дифы в базе, так как мне прислали новый элемент ', {
                              err: err
                            });
                          });
                          mythis.copyObject(mythis._db[db_name][confirm_id], doc);
                          __log.debug('syncApply', '!= Есть данные в бекапе, сохраняю в память _sha1 = ' + doc._sha1, {
                            doc: doc
                          });
                          mythis.db.put(db_name, doc).done(function(err) {
                            __log.debug('syncApply', '!= Есть данные в бекапе, сохранил в базу _sha1 = ' + doc._sha1, {
                              doc: doc
                            });
                            return $timeout(function() {
                              $rootScope.$emit('refresh_editor');
                              return __log.warn('syncApply', '!= Попросил редактор обновиться ', {
                                doc: doc
                              });
                            }, 100);
                          });
                        }
                      } else {
                        __log.warn('Документ целиком не прислали, просто подтвердили старое изменение, нужно удалить дифы до нового изменения');
                      }
                      if (old_doc && !confirm_element.merged && doc) {
                        __log.warn('syncApply', 'Данные есть в кеше, но sha1 другой!!!!!!!!!!!!!!!!', {
                          old_doc: old_doc,
                          doc: doc
                        });
                        patch = mythis.diff.diff(JSON.parse(JSON.stringify(old_doc)), doc);
                        __log.warn('BUG: ', {
                          old_doc: old_doc,
                          doc: doc,
                          patch: patch
                        });
                        if (patch && patch._sha1) {
                          delete patch._sha1;
                        }
                        if (patch && patch._tm) {
                          delete patch._tm;
                        }
                        __log.warn('PATCH = ', patch);
                        if (patch) {
                          el = {
                            _id: confirm_id,
                            patch: patch,
                            db_name: db_name,
                            _sha1: old_doc._sha1,
                            user_id: settingsApi.set.user_id,
                            machine: settingsApi.set.machine,
                            _tm: new Date().getTime()
                          };
                          __log.warn('!!!!!!!!!!!SHA1!!!!!!', doc._sha1, doc);
                          mythis.saving_diff_busy = true;
                          mythis._tmp._diffs[el._id] = el;
                        }
                        mythis._db[db_name][confirm_id] = doc;
                        return mythis.db.put(db_name, old_doc).done(function(err) {
                          __log.warn('old_saved _Sha1 = ', old_doc._sha1);
                          return mythis.db.put('_diffs', el).done(function() {
                            $timeout(function() {
                              $rootScope.$emit('refresh_editor');
                              return __log.warn('syncApply', '!= Попросил редактор обновиться SHA1 ERROR', {
                                doc: doc
                              });
                            }, 100);
                            return mythis.saving_diff_busy = false;
                          });
                        });
                      }
                    }
                  } else {
                    if (confirm_element._doc) {
                      mythis.clearCache();
                      mythis._db[db_name][confirm_element._doc._id] = confirm_element._doc;
                      return mythis.db.put(db_name, confirm_element._doc).done(function(err) {
                        return __log.info('saved_to_db ', err);
                      });
                    }
                  }
                });
              });
            }
          });
          dfd.resolve();
          return dfd.promise;
        },
        getLastSyncTime: function() {
          var dfd, max_element, max_time, mythis, new_db_elements;
          dfd = $q.defer();
          max_time = new Date(2013, 3, 1);
          max_element = new Date(2013, 3, 1);
          mythis = this;
          new_db_elements = {};
          async.each(mythis.store_schema, function(table_schema, callback) {
            var db_name;
            db_name = table_schema.name;
            if (db_name[0] !== '_') {
              __log.info({
                db_name: db_name
              });
              max_element = _.max(mythis._db[db_name], function(el) {
                if (el._new) {
                  if (!new_db_elements[db_name]) {
                    new_db_elements[db_name] = {};
                  }
                  new_db_elements[db_name][el._id] = el;
                }
                if (el._tm) {
                  return new Date(el._tm);
                } else {
                  return 0;
                }
              });
              if (new Date(max_element._tm) > max_time) {
                max_time = new Date(max_element._tm);
              }
              return callback();
            } else {
              return callback();
            }
          }, function() {
            return dfd.resolve({
              last_sync_time: max_time,
              new_db_elements: new_db_elements
            });
          });
          return dfd.promise;
        },
        jsSyncJournalCount: function() {
          if (this._tmp._diffs) {
            return Object.keys(this._tmp._diffs).length;
          } else {
            return 0;
          }
        },
        sync_now: false,
        sync_later: void 0,
        last_sync_time: 'не проводилась',
        syncDiff: function() {
          var dfd, mythis, sync_id;
          dfd = $q.defer();
          mythis = this;
          if (!mythis.sync_now) {
            $('.sync_indicator').addClass('active');
            setTimeout(function() {
              return $('.sync_indicator').removeClass('active');
            }, 950);
            mythis.sync_now = true;
            if (__log.show_time_long) {
              console.time('sync_long');
            }
            sync_id = Math.round(Math.random() * 100);
            __log.info('(' + sync_id + ') New syncing...');
            this.getDiffsForSync().then(function(diffs) {
              if ($socket.is_online() && false) {
                return mythis.syncThrough('websocket', data).then(function() {
                  __log.info('sync_socket_ended');
                  mythis.sync_now = false;
                  return dfd.resolve();
                });
              } else {
                return mythis.sendDiffToWeb(diffs).then(function(results) {
                  return mythis.syncApplyResults(results).then(function() {
                    var now;
                    mythis.refreshParentsIndex();
                    mythis.sync_now = false;
                    dfd.resolve();
                    __log.info('sha1 applyed');
                    __log.info('(' + sync_id + ') STOP syncing...');
                    if (__log.show_time_long) {
                      console.time('sync_long');
                    }
                    $('.sync').removeClass('need_sync');
                    now = new moment();
                    return mythis.last_sync_time = now.format("HH:mm:ss");
                  });
                });
              }
            });
          } else {
            clearTimeout(mythis.sync_later);
            mythis.sync_later = setTimeout(function() {
              mythis.syncDiff();
              return __log.warn('SyncAgain...');
            }, 500);
            __log.warn('cant sync now, already syncing...................');
          }
          return dfd.promise;
        },
        sendDiffToWeb: function(diffs) {
          var dfd, mythis, _ref;
          __log.info('Sending: ', (_ref = JSON.stringify(diffs)) != null ? _ref.length : void 0);
          dfd = $q.defer();
          mythis = this;
          return mythis.getLastSyncTime().then(function(last_sync_time_and_new) {
            var last_sync_time, new_db_elements, sha1_sign;
            last_sync_time = last_sync_time_and_new.last_sync_time;
            new_db_elements = last_sync_time_and_new.new_db_elements;
            sha1_sign = settingsApi.set.machine + mythis.JSON_stringify({
              diffs: diffs,
              new_db_elements: new_db_elements
            })._sha1;
            oAuth2Api.jsGetToken().then(function(token) {
              return $http({
                url: settingsApi.set.server + '/api/v2/sync',
                method: "POST",
                isArray: true,
                params: {
                  access_token: token,
                  machine: settingsApi.set.machine,
                  last_sync_time: last_sync_time
                },
                data: {
                  diffs: diffs,
                  new_db_elements: new_db_elements,
                  sha1_sign: sha1_sign,
                  user_id: settingsApi.set.user_id
                }
              }).then(function(result) {
                return dfd.resolve(result.data);
              });
            });
            return dfd.promise;
          });
        },
        before_sync: {},
        getDiffsForSync: function() {
          var dfd, diffs, machine_id, mythis;
          dfd = $q.defer();
          mythis = this;
          diffs = mythis._tmp._diffs;
          machine_id = settingsApi.set.machine;
          if (machine_id === '7829517' && diffs && Object.keys(diffs).length) {
            alert('stop!');
          }
          mythis.before_sync = {};
          if (!!diffs) {
            async.each(Object.keys(diffs), function(dif_id, callback) {
              var dif;
              dif = diffs[dif_id];
              __log.info('dif = ', dif);
              return mythis.getElement(dif.db_name, dif._id).then(function(now_element) {
                var _ref, _ref1;
                if (now_element) {
                  mythis.before_sync[dif._id] = JSON.parse(JSON.stringify(now_element));
                  mythis.before_sync[dif._id]._sha1 = mythis.JSON_stringify(mythis.before_sync[dif._id])._sha1;
                  __log.warn('backup = ', mythis.before_sync[dif._id]);
                }
                if ((_ref = mythis._tmp._send_doc_next_time) != null ? (_ref1 = _ref[dif.db_name]) != null ? _ref1[dif._id] : void 0 : void 0) {
                  return mythis.getElementFromLocal(dif.db_name, dif._id).then(function(old_element) {
                    var _ref2, _ref3;
                    if (old_element._sha1 === ((_ref2 = mythis._tmp._send_doc_next_time) != null ? (_ref3 = _ref2[dif.db_name]) != null ? _ref3[dif._id] : void 0 : void 0)) {
                      dif._doc = old_element;
                      return callback();
                    } else {
                      console.error('strange, sha1 of local not equal');
                      return callback();
                    }
                  });
                } else {
                  return callback();
                }
              });
            }, function() {
              return dfd.resolve(diffs);
            });
          } else {
            dfd.resolve();
          }
          return dfd.promise;
        },
        TestJson: function() {
          var mythis;
          mythis = this;
          return $timeout(function() {
            __log.info('start test JSON');
            if (__log.show_time_long) {
              console.time('JSON_test');
            }
            _.each(['tree', 'tasks', 'texts'], function(db_name) {
              var i;
              i = 0;
              _.each(mythis._db[db_name], function(element) {
                var answer;
                answer = mythis.JSON_stringify(element);
                if (answer._sha1 !== element._sha1) {
                  __log.info('SHA1 error [' + i + ']', element, answer);
                  return i++;
                }
              });
              if (i === 0) {
                return __log.info('Congratulations.. ' + db_name + ' is equal...');
              }
            });
            if (__log.show_time_long) {
              return console.timeEnd('JSON_test');
            }
          }, 3000);
        },
        JSON_stringify: function(json) {
          var copyObjectWithSortedKeys, delete_, isArray, isObject, json2, string, _id, _sha1;
          isObject = function(a) {
            return Object.prototype.toString.call(a) === "[object Object]";
          };
          isArray = function(a) {
            return Object.prototype.toString.call(a) === "[object Array]";
          };
          copyObjectWithSortedKeys = function(object) {
            var i, key, keysSorted, newObj;
            if (isObject(object)) {
              newObj = {};
              keysSorted = Object.keys(object).sort();
              key = void 0;
              for (i in keysSorted) {
                key = keysSorted[i];
                if (_.has(object, key)) {
                  newObj[key] = copyObjectWithSortedKeys(object[key]);
                }
              }
              return newObj;
            } else if (isArray(object)) {
              return object.map(copyObjectWithSortedKeys);
            } else {
              return object;
            }
          };
          delete_ = function(key, value) {
            var first_letter;
            if ((first_letter = key[0]) === '_' || first_letter === '$') {
              return void 0;
            } else {
              return value;
            }
          };
          json2 = copyObjectWithSortedKeys(JSON.parse(JSON.stringify(json, delete_)));
          string = JSON.stringify(json2, delete_, 0);
          _id = json != null ? json._id : void 0;
          _sha1 = CryptoJS.SHA1(JSON.stringify(string)).toString().substr(0, 7);
          return {
            _id: _id,
            _sha1: _sha1,
            string: string
          };
        }
      };
    }
  ]);

}).call(this);

//# sourceMappingURL=srv_db_tree.map
