// Generated by CoffeeScript 1.6.3
(function() {
  angular.module("4treeApp").service('syncApi', [
    '$translate', function($translate) {
      return {
        constructor: function() {
          this.color = 'grey';
          this.log_show = true;
          return this.sync_journal = [];
        },
        jsEach: function(elements, fn, name) {
          if (name == null) {
            name = '';
          }
          return _.each(elements, function(el, key) {
            var dot, name1;
            if (!_.isObject(el)) {
              dot = name ? '.' : '';
              key = name + dot + key;
              return fn.call(this, el, key);
            } else {
              dot = name ? '.' : '';
              name1 = name + dot + key;
              return this.jsEach(el, fn, name1);
            }
          });
        },
        jsGetByPoints: function(obj, points, create_if_not_finded) {
          var prev_obj, split_point;
          split_point = points.split(".");
          prev_obj = obj;
          _.each(split_point, function(point, i) {
            prev_obj = obj;
            if (!obj[point]) {
              if (create_if_not_finded) {
                return obj = obj[point] = {};
              }
            } else {
              return obj = obj[point];
            }
          });
          prev_obj;
          return {
            jsDryObjectBySyncJournal: function(tree, journal) {
              var answer, fn;
              fn = this;
              if (this.log_show) {
                console.info('tree = ', tree);
              }
              if (this.log_show) {
                console.info('journal = ', journal);
              }
              if (this.log_show) {
                console.info('--------------');
              }
              answer = [];
              _.each(journal, function(jr) {
                var element, tree_by_id;
                tree_by_id = tree['n' + jr.id];
                if (!tree_by_id) {
                  return 0;
                }
                element = {
                  id: jr.id,
                  _tm: jr.tm
                };
                _.each(jr.changes, function(change_field_name) {
                  var e, last_field_name;
                  points = change_field_name.split('.');
                  e = fn.jsGetByPoints(element, change_field_name, '	create_if_not_finded');
                  last_field_name = points[points.length - 1];
                  return e[last_field_name] = this.jsGetByPoints(tree_by_id, change_field_name)[last_field_name];
                });
                return answer.push(element);
              });
              return answer;
            }
          };
        },
        jsAddToSyncJournal: function(new_element, old_element) {
          var answer, fn, journal_exist, journal_exist_last;
          fn = this;
          answer = {
            changes: []
          };
          this.jsEach(new_element, function(el, key) {
            var last_key, spl;
            spl = key.split(".");
            last_key = spl[spl.length - 1];
            if (el !== fn.jsGetByPoints(old_element, key)[last_key]) {
              answer.tm = new Date();
              answer.type = 'update';
              answer.id = new_element.id;
              answer.table = '4tree';
              return answer.changes.push(key);
            }
          });
          journal_exist = _.filter(this.sync_journal, function(el) {
            return el.id === answer.id;
          });
          journal_exist_last = _.max(journal_exist, function(el) {
            return el.tm;
          });
          if (journal_exist_last.length) {
            journal_exist_last.changes = _.union(journal_exist_last.changes, answer.changes);
          } else {
            this.sync_journal.push(answer);
          }
          console.info('journal_exist = ', this.sync_journal);
          return this.sync_journal;
        }
      };
    }
  ]);

}).call(this);
